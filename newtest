import os
import requests
from datetime import datetime, timedelta
import json
import telebot
from telebot import types
from bs4 import BeautifulSoup
import feedparser
import yfinance as yf
import openai
import re

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_TOKEN = 'YOUR_TELEGRAM_TOKEN'  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω
RBC_RSS_URL = 'https://rssexport.rbc.ru/rbcnews/news/30/full.rss'
FOREX_API = 'https://api.exchangerate-api.com/v4/latest/USD'
CRYPTO_API = 'https://api.coingecko.com/api/v3/simple/price'
STOCK_API = yf
FORBES_URL = 'https://www.forbes.com/business/'
TELEGRAM_PREMIUM_API = 'https://fragment.com/numbers'

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = telebot.TeleBot(TELEGRAM_TOKEN)

NEWSAPI_KEY = 'YOUR_NEWSAPI_KEY'  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –∫–ª—é—á
OPENAI_API_KEY = 'YOUR_OPENAI_KEY'  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –∫–ª—é—á
openai.api_key = OPENAI_API_KEY

user_states = {}

def set_state(chat_id, state, data=None):
    user_states[chat_id] = {'state': state, 'data': data}

def get_state(chat_id):
    state_data = user_states.get(chat_id)
    return state_data['state'] if state_data else None

def get_data(chat_id):
    state_data = user_states.get(chat_id)
    return state_data['data'] if state_data else None

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã (–¢–û–õ–¨–ö–û –û–î–ù–û –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï!)
def create_main_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton('üìà –ê–∫—Ü–∏–∏'))
    keyboard.add(types.KeyboardButton('üîç –ü–æ–∏—Å–∫ –∞–∫—Ü–∏–π'))  
    keyboard.add(types.KeyboardButton('üí± –í–∞–ª—é—Ç—ã'))
    keyboard.add(types.KeyboardButton('üì∞ –ù–æ–≤–æ—Å—Ç–Ω–∞—è –≤—ã–∂–∏–º–∫–∞'))
    keyboard.add(types.KeyboardButton('üì∞ –ü–æ—Å–ª–µ–¥–Ω—è—è –Ω–æ–≤–æ—Å—Ç—å —Å –ü—É–ª—å—Å–∞'))
    keyboard.add(types.KeyboardButton('‚ÑπÔ∏è –û –±–æ—Ç–µ'))
    return keyboard

def create_stocks_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton('üá∑üá∫ –†–æ—Å—Å–∏–π—Å–∫–∏–µ –∞–∫—Ü–∏–∏'))
    keyboard.add(types.KeyboardButton('üá∫üá∏ –ê–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏–µ –∞–∫—Ü–∏–∏'))
    keyboard.add(types.KeyboardButton('üîô –ù–∞–∑–∞–¥'))
    return keyboard

def create_currency_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton('üíµ USD/RUB'))
    keyboard.add(types.KeyboardButton('üí∂ EUR/RUB'))
    keyboard.add(types.KeyboardButton('üí∑ GBP/RUB'))
    keyboard.add(types.KeyboardButton('üí¥ CNY/RUB'))
    keyboard.add(types.KeyboardButton('‚Çø –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã'))
    keyboard.add(types.KeyboardButton('üîô –ù–∞–∑–∞–¥'))
    return keyboard

# –§—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –∞–∫—Ü–∏–π
def search_stocks(query):
    try:
        url = "https://fin-plan.org/stocks/rus/"
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –∞–∫—Ü–∏–π
        stocks = []
        stock_items = soup.select('.stock-item')  # –ò–∑–º–µ–Ω–∏—Ç–µ —Å–µ–ª–µ–∫—Ç–æ—Ä –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ä–µ–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π —Å–∞–π—Ç–∞
        
        for item in stock_items:
            try:
                name = item.select_one('.stock-name').text.strip()
                price = item.select_one('.stock-price').text.strip()
                if query.lower() in name.lower():
                    stocks.append((name, price))
            except:
                continue
        
        return stocks[:10]  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ –±–æ–ª–µ–µ 10 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∞–∫—Ü–∏–π: {str(e)}")
        return [("–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞", "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ")]

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@bot.message_handler(commands=['start'])
def send_welcome(message):
    set_state(message.chat.id, None)
    bot.send_message(
        message.chat.id,
        "üìä <b>–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –ø–æ–º–æ—â–Ω–∏–∫</b>\n\n"
        "–Ø –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ:\n"
        "- –ö—É—Ä—Å–∞—Ö –≤–∞–ª—é—Ç üí±\n"
        "- –°—Ç–æ–∏–º–æ—Å—Ç–∏ –∞–∫—Ü–∏–π üìà\n"
        "- –ù–æ–≤–æ—Å—Ç–Ω–∞—è –≤—ã–∂–∏–º–∫–∞ üì∞\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–∏–π –≤–∞—Å —Ä–∞–∑–¥–µ–ª:",
        parse_mode='HTML',
        reply_markup=create_main_keyboard()
    )

@bot.message_handler(func=lambda message: message.text == 'üîç –ü–æ–∏—Å–∫ –∞–∫—Ü–∏–π')
def start_stock_search(message):
    set_state(message.chat.id, 'waiting_stock_query')
    bot.send_message(
        message.chat.id,
        "üîç –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–∫—Ü–∏–∏ –∏–ª–∏ —Ç–∏–∫–µ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ì–∞–∑–ø—Ä–æ–º –∏–ª–∏ GAZP):",
        reply_markup=types.ReplyKeyboardRemove()
    )

@bot.message_handler(func=lambda message: get_state(message.chat.id) == 'waiting_stock_query')
def handle_stock_query(message):
    try:
        bot.send_message(message.chat.id, "‚è≥ –ò–¥–µ—Ç –ø–æ–∏—Å–∫... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.")
        matches = search_stocks(message.text.strip())
        
        if not matches:
            bot.send_message(message.chat.id, "‚ùå –ê–∫—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.", reply_markup=create_main_keyboard())
            set_state(message.chat.id, None)
            return
        
        if len(matches) == 1:
            name, price = matches[0]
            bot.send_message(message.chat.id, f"üìã <b>{name}</b>\nüí∞ –¶–µ–Ω–∞: {price}", parse_mode='HTML', reply_markup=create_main_keyboard())
            set_state(message.chat.id, None)
        else:
            response = "üîç –ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–∫—Ü–∏–π:\n\n"
            for idx, (name, price) in enumerate(matches, 1):
                response += f"{idx}. {name} - {price}\n"
            
            response += "\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∞–∫—Ü–∏–∏ –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏:"
            bot.send_message(message.chat.id, response)
            set_state(message.chat.id, 'waiting_stock_choice', data=matches)
    
    except Exception as e:
        bot.send_message(message.chat.id, f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞: {str(e)}", reply_markup=create_main_keyboard())
        set_state(message.chat.id, None)

@bot.message_handler(func=lambda message: get_state(message.chat.id) == 'waiting_stock_choice')
def handle_stock_choice(message):
    try:
        matches = get_data(message.chat.id)
        if not matches:
            bot.send_message(message.chat.id, "‚ùå –î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏. –ù–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.", reply_markup=create_main_keyboard())
            set_state(message.chat.id, None)
            return
        
        choice = int(message.text.strip())
        if 1 <= choice <= len(matches):
            name, price = matches[choice-1]
            bot.send_message(message.chat.id, f"üìã <b>{name}</b>\nüí∞ –¶–µ–Ω–∞: {price}", parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ {len(matches)}")
    except ValueError:
        bot.send_message(message.chat.id, "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä.")
    finally:
        set_state(message.chat.id, None)
        bot.send_message(message.chat.id, "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=create_main_keyboard())

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
if __name__ == '__main__':
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    bot.infinity_polling()
